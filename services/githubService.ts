import { GitHubUser } from '../types';
import { strToBase64, sanitizePath } from './utils';

const GITHUB_API_BASE = 'https://api.github.com';

const makeRequest = async <T>(token: string, endpoint: string, options: RequestInit = {}): Promise<T> => {
    const headers = {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/vnd.github.v3+json',
        'Content-Type': 'application/json',
        ...options.headers,
    };

    const response = await fetch(`${GITHUB_API_BASE}${endpoint}`, {
        ...options,
        headers,
    });

    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `GitHub API error: ${response.status}`);
    }

    if (response.status === 204) {
        return null as T;
    }

    return response.json();
};

export const getUser = (token: string): Promise<GitHubUser> => {
    return makeRequest<GitHubUser>(token, '/user');
};

export const createRepo = (token: string, name: string): Promise<any> => {
    return makeRequest<any>(token, '/user/repos', {
        method: 'POST',
        body: JSON.stringify({
            name,
            description: 'Config generated by Replit to Render Deployer',
            private: false,
            auto_init: true, // Initializes with a README, creating the main branch.
        }),
    });
};


export const commitMultipleFiles = async (
    token: string,
    owner: string,
    repo: string,
    files: { [fileName: string]: string },
    commitMessage: string
): Promise<void> => {
    // Sanitize file paths as a final safeguard. Paths from the geminiService
    // should already be clean, but this prevents any other source of malformed paths.
    const sanitizedFiles: { [fileName: string]: string } = {};
    for (const [path, content] of Object.entries(files)) {
        const sanitizedPath = sanitizePath(path);
        if (sanitizedPath) {
            sanitizedFiles[sanitizedPath] = content;
        }
    }

    // 1. Get the latest commit SHA from the main branch
    const mainRef = await makeRequest<any>(token, `/repos/${owner}/${repo}/git/refs/heads/main`);
    const latestCommitSha = mainRef.object.sha;

    // 2. Get the tree SHA from that latest commit
    const latestCommit = await makeRequest<any>(token, `/repos/${owner}/${repo}/git/commits/${latestCommitSha}`);
    const baseTreeSha = latestCommit.tree.sha;

    // 3. Create blob objects for each file content using the sanitized files
    const blobCreationPromises = Object.entries(sanitizedFiles).map(async ([path, content]) => {
        const blob = await makeRequest<{ sha: string }>(token, `/repos/${owner}/${repo}/git/blobs`, {
            method: 'POST',
            body: JSON.stringify({
                content: strToBase64(content),
                encoding: 'base64',
            }),
        });
        return {
            path,
            mode: '100644' as const,
            type: 'blob' as const,
            sha: blob.sha,
        };
    });
    const treeItems = await Promise.all(blobCreationPromises);

    // 4. Create a new tree object with the new file blobs
    const newTree = await makeRequest<{ sha: string }>(token, `/repos/${owner}/${repo}/git/trees`, {
        method: 'POST',
        body: JSON.stringify({
            base_tree: baseTreeSha,
            tree: treeItems,
        }),
    });

    // 5. Create a new commit object
    const newCommit = await makeRequest<{ sha: string }>(token, `/repos/${owner}/${repo}/git/commits`, {
        method: 'POST',
        body: JSON.stringify({
            message: commitMessage,
            tree: newTree.sha,
            parents: [latestCommitSha],
        }),
    });

    // 6. Update the main branch reference to point to the new commit
    await makeRequest(token, `/repos/${owner}/${repo}/git/refs/heads/main`, {
        method: 'PATCH',
        body: JSON.stringify({
            sha: newCommit.sha,
        }),
    });
};